                                                  Recursion
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Backtracking
	- A strategy for guessing at a solution and backing up when an impasse is reached

Formal definition for JavaPrograms
   +++++++++++++++++++
   |: - such that    |
   |{} - all strings |
   |= - consists of  |
   +++++++++++++++++++
	(The language JavaPrograms consists of all strings w such that w is syntactically correct Java program)
	JavaPrograms = {strings w : w is syntactically correct Java program}

	AlgebraicExpressions = {w : w is an algebraic expression}

Defining Languages
	
	Grammar
		- States the rules for forming the strings in a language
	
	Benefits of recursive grammars
		- A recognition algorithm determines whether a given string is in the language

Basic of Grammar
 
	- x|y means x or y
	- xy means x followed by y 
	- <word> means any instance of work that the definition defines
	
Java Identifiers
	
	- A Java identifier begins with a letter and is followed by zero or more letters and digits		
	
	- JavaIds = {w : w is a legal Java identifier
	
	- <identifier> = <letter> | <identifier><letter> | <identifier><digit>
	- <letter> = a|b|...|z|A|B|...|Z|_|$
	- <digits> = 0|1|...|9
	
	Recognition algorithm
		isId(w)
		if(w is of length 1)
		{
			if(w is a letter)
			{
			return true
			}
			else
			{
			return false
			}
		}
		else if(the last character of w is a letter or a digit)
		{
			return isId(w minus its last character)
		}
		else
		{
			return false
		}
	
Palindromes
	
	- A string that reads the same from left to right as its does from right to left
	- Ex: radar, deed
	- Language
		Palindromes = {w : w reads the same left to right as right to left}
		
	Grammar
		- <pal> = empty string | <ch> | a<pal>a | b <pal> b |...|Z<pal>Z
		- <ch> = a|b|...|z|A|B|...|Z
		
	Recognition algorithm
		isPal(w)
			if(w is the empty string or w is of length 1)
			{
				return true
			}
			else if(w's first and last character are the same letter)
			{
				return isPal(w minus its first and last character)
			}
			else
			{
				return false
			}
		
Form A^nB^n

	- The string that consists of n consecutive A's followed by n consecutive B's
	- L = {w : w is of the form A^nB^n for some n >= 0}
	- <legal-word> = empty string | A<legal-word>B
	
	Recognition Algorithm
		isAnBn(w)
			if(the length of w is zero)
			{
				return true
			}
			else if(w begins with the character A and ends with the character B)
			{
			return isAnBn(w minus its first and last character)
			}
			else
			{
				return false
			}
			
Three languages for algebraic expressions
	(Pre and Post will never need ( )..)
	- Infix expressions
		- An operator appears between its operands
		- Ex: a+b
	- Prefix
		- An operator appears before its operands
		- Ex: +ab
	- Postfix expressions
		- An operator appears after its operands
		- Ex: ab+	
	
Convert a fully parenthesized infix expression to a prefix form
	- Move each operator to the position marked by its corresponding open parenthiesis
	- Remove the parentheses
	- Ex: Infix Expression: ((a+b) * c)
	     Prefix Expression: *+abc
	     	 	
Convert a fully parenthesized infix expression to a postfix form
	- Move each operator to the position marked by its corresponding closing parenthesis
	- Remove the parentheses
	- Ex: Infix form: ((a+b)*c)
	    Postfix form: ab+c*
	    
Prefix Expressions
 
 	- Grammar
 		- <prefix> = <identifier> | <operator><prefix><prefix> <operator>=+a|b|-|*|/<identifier>=a|b|...|z
 		- A recognition algorithm
 			isPre()
 				size = length of expression strExp
 				lastChar = endPre(0, size - 1)
 				if(lastChar >= 0 and lastChar == size - 1
 				{
 					return true
 				}
 				else
 				{
 					return false
 				}
 			
 			private int endPre(int first, int last)
 			{
 				if(first < 0 || first> last)
 				{
 					return -1
 				}
 				ch = char @ position first of stringExp
 				if(chi is <ID>)
 				{
 					return first
 				}
 				else if(ch is <op>)
 				{
 					firstEnd = enPre(first + 1, last)
 					
 					if(firstEnd > -1)
 					{
 						return endPre(first + 1, last)
 					}
 					else
 					{
 						return -1
 					}
 				else
 				{
 					return -1
 				}	
 			}
 			
 Postfix Expression
 
 	Grammar:
 		<postfix> = <identifier>|<postfix><postfix><operator>
 		<operator> = +|-|/ |*
 		<identifier> = a|b|...|z
 		
 	Algorithm:
 		
 		Convert prefix to postfix
 		
 		convert(pre)
 			ch = first char of pre
 			delete first char of pre
	 		if(ch is a lowercase letter)
	 		{
	 			return ch as a string
	 		}
	 		else
	 		{
	 			postfix1 = convert(pre)
	 			postfix2 = convert(pre)
	 			return prefix1 + prefix2 + ch
	 		}
 		
 				
 		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	